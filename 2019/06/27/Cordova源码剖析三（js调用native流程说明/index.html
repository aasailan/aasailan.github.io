<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.2 -->
    <script>
        window.materialVersion = "1.5.2"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            Cordova源码剖析三（js调用native流程说明) | 
        
        aasailan的blog
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="aasailan的blog">
    <meta name="keywords" content=",前端,cordova,源码剖析">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?MKetZV3cUTfDxvMffaOezg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #3F3F3F;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?ezyEvm8ST5CGfpA+kFFi1g==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="aasailan的blog">
    <meta name="msapplication-starturl" content="http://yoursite.com/2019/06/27/Cordova源码剖析三（js调用native流程说明/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="aasailan的blog">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://yoursite.com/2019/06/27/Cordova源码剖析三（js调用native流程说明/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="Cordova源码剖析三（js调用native流程说明) | aasailan的blog">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="aasailan的blog">
    <meta property="og:article:tag" content="前端"> <meta property="og:article:tag" content="cordova"> <meta property="og:article:tag" content="源码剖析"> 

    
        <meta property="article:published_time" content="Thu Jun 27 2019 17:20:37 GMT+0800">
        <meta property="article:modified_time" content="Thu Jun 27 2019 18:57:45 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://yoursite.com/2019/06/27/Cordova源码剖析三（js调用native流程说明/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://yoursite.com/2019/06/27/Cordova源码剖析三（js调用native流程说明/index.html",
    "headline": "Cordova源码剖析三（js调用native流程说明)",
    "datePublished": "Thu Jun 27 2019 17:20:37 GMT+0800",
    "dateModified": "Thu Jun 27 2019 18:57:45 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "aasailan",
        "image": {
            "@type": "ImageObject",
            "url": "/img/touxiang.jpg"
        },
        "description": "程序员是一个值得自豪的职业"
    },
    "publisher": {
        "@type": "Organization",
        "name": "aasailan的blog",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": ",前端,cordova,源码剖析",
    "description": "aasailan的blog",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span id="MD-burger-id" class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#cordova中js调用android原生代码的过程剖析"><span class="post-toc-number">1.</span> <span class="post-toc-text">cordova中js调用android原生代码的过程剖析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#从Toast插件接口到调用Native方法"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">从Toast插件接口到调用Native方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进入native方法后如何调用到对应的插件"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">进入native方法后如何调用到对应的插件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#native中的线程与js中的异步"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">native中的线程与js中的异步</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#native端对js进行的回调"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">native端对js进行的回调</span></a></li></ol></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                Cordova源码剖析三（js调用native流程说明)
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/touxiang.jpg" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>aasailan</strong>
        <span>6月 27, 2019</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/cordova/">cordova</a></li><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/前端/">前端</a></li><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/源码剖析/">源码剖析</a>
    </ul>
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    

    <!-- Share Twitter -->
    

    <!-- Share Facebook -->
    

    <!-- Share Google+ -->
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <h1 id="cordova中js调用android原生代码的过程剖析"><a href="#cordova中js调用android原生代码的过程剖析" class="headerlink" title="cordova中js调用android原生代码的过程剖析"></a>cordova中js调用android原生代码的过程剖析</h1><p>这篇文章以toast插件为例，剖析cordova中js调用android原生代码以及native对js进行回调的整个过程，中间涉及到三个比较重要的点：</p>
<ol>
<li>js插件如何通过cordova.exec调用到native方法</li>
<li>进入native方法后如何调用到对应的插件</li>
<li>插件执行后如何回调js</li>
</ol>
<h2 id="从Toast插件接口到调用Native方法"><a href="#从Toast插件接口到调用Native方法" class="headerlink" title="从Toast插件接口到调用Native方法"></a>从Toast插件接口到调用Native方法</h2><p>在js一侧调用toast的js插件暴露出来的方法</p>
<pre><code class="javascript">window.plugins.toast.show(&#39;ps^^, you are in my code&#39;, &#39;short&#39;, &#39;bottom&#39;, function(res) {
  console.log(res);
}, function(error) {
  console.log(error);
});
</code></pre>
<p>window.plugins.toast对象是Toast插件的js部分代码添加的，深入plugins/cordova-plugin-x-toast/www/Toast.js文件中可以看到该对象的封装过程。该文件会在cordova.js运行启动框架的过程中被动态加载到html。（具体描述可以参考上一篇文章）</p>
<pre><code class="javascript">cordova.define(&quot;cordova-plugin-x-toast.Toast&quot;, function (require, exports, module) {
  // 定义一个Toast类构造函数
  function Toast() {
  }

  ....

  Toast.prototype.showWithOptions = function (options, successCallback, errorCallback) {
    options.duration = (options.duration === undefined ? &#39;long&#39; : options.duration.toString());
    options.message = options.message.toString();
    // 注意cordova.exec的传参方法 https://cordova.apache.org/docs/en/latest/guide/hybrid/plugins/index.html#the-javascript-interface
    // 调用利用cordova.exec方法，cordova.exec方法是js调用插件的统一入口
    cordova.exec(successCallback, errorCallback, &quot;Toast&quot;, &quot;show&quot;, [options]);
  };

  Toast.prototype.show = function (message, duration, position, successCallback, errorCallback) {
    this.showWithOptions(
      this.optionsBuilder()
        .withMessage(message)
        .withDuration(duration)
        .withPosition(position) 
        .build(),
      successCallback,
      errorCallback);
  };

  ...
  // 定义install方法把Toast插件实例放置到window对象上
  Toast.install = function () {
    if (!window.plugins) {
      window.plugins = {};
    }

    window.plugins.toast = new Toast();
    return window.plugins.toast;
  };

  // 在cordovaReady事件上注册一个回调，等待触发后，插件安装
  // cordovaReady是一个sticky channel
  cordova.addConstructor(Toast.install);
}
</code></pre>
<p>上面的js代码主要做了三件事情</p>
<ol>
<li>定义了一个cordova module</li>
<li>在module的factory函数中，使用Toast类封装了对cordova.exec方法的调用。利用Toast类实例来对外暴露Toast插件的调用接口</li>
<li>在cordovaReady这个channel中添加回调处理，在回调中将Toast类实例添加到window对象上</li>
</ol>
<p>以上三步也是其他插件的js部分代码几乎都会做的通用三步。</p>
<p>所以window.plugins.toast.show方法会调用到cordova.exec方法，而cordova.exec方法其实就是定义在cordova.js内的androidExec方法。</p>
<pre><code class="javascript">/**
     * @description cordova.exec方法定义，js调用插件的统一入口
     * @param {function} success 成功回调函数 
     * @param {function} fail 错误回调函数
     * @param {string} service 插件名
     * @param {string} action 插件内部的action名
     * @param {Array&lt;any&gt;} args 参数数组
     */
    function androidExec(success, fail, service, action, args) {
      if (bridgeSecret &lt; 0) {
        // If we ever catch this firing, we&#39;ll need to queue up exec()s
        // and fire them once we get a secret. For now, I don&#39;t think
        // it&#39;s possible for exec() to be called since plugins are parsed but
        // not run until until after onNativeReady.
        throw new Error(&#39;exec() called without bridgeSecret&#39;);
      }
      // Set default bridge modes if they have not already been set.
      // By default, we use the failsafe, since addJavascriptInterface breaks too often
      if (jsToNativeBridgeMode === undefined) {
        // 首次调用原生方式，尝试使用js_object方式，setJsToNativeBridgeMode做了兼容处理，如果无法使用js_object方式，则使用prompt方式
        androidExec.setJsToNativeBridgeMode(jsToNativeModes.JS_OBJECT);
      }

      // If args is not provided, default to an empty array
      // 保证原生收到的参数起码是个空数组
      args = args || [];

      // Process any ArrayBuffers in the args into a string.
      for (var i = 0; i &lt; args.length; i++) {
        // 如果参数对象是一个数组，则需要把这个数组编码成base64
        if (utils.typeName(args[i]) == &#39;ArrayBuffer&#39;) {
          console.log(&#39;before base64&#39;, args[i]);
          args[i] = base64.fromArrayBuffer(args[i]);
          console.log(&#39;after base64&#39;, args[i]);
        }
      }

      var callbackId = service + cordova.callbackId++,
        argsJson = JSON.stringify(args);
      if (success || fail) {
        // 将success回调函数和fail回调函数封装成对象，动态添加到cordova.callbacks对象中
        cordova.callbacks[callbackId] = { success: success, fail: fail };
      }

      // 通过nativeApiProvider获取原生api提供对象并执行原生方法，
      // NOTE: 这个msgs是否是执行原生方法后直接返回的结果，而不是native的callback回调
      // 具体的消息结果参见CordovaBridge.jsExec方法内的jsMessageQueue.popAndEncode方法调用
      console.log(&#39;plugin exec start:&#39;, bridgeSecret, service, action, callbackId, argsJson);
      var msgs = nativeApiProvider.get().exec(bridgeSecret, service, action, callbackId, argsJson);
      console.log(&#39;plugin exec end:&#39;, callbackId, msgs);
      // If argsJson was received by Java as null, try again with the PROMPT bridge mode.
      // This happens in rare circumstances, such as when certain Unicode characters are passed over the bridge on a Galaxy S2.  See CB-2666.
      if (jsToNativeBridgeMode == jsToNativeModes.JS_OBJECT &amp;&amp; msgs === &quot;@Null arguments.&quot;) {
        // 如果原生方法返回@Null arguments.则使用prompt方法尝试再调用一次
        androidExec.setJsToNativeBridgeMode(jsToNativeModes.PROMPT);
        androidExec(success, fail, service, action, args);
        androidExec.setJsToNativeBridgeMode(jsToNativeModes.JS_OBJECT);
      } else if (msgs) {
        // 将原生回传的信息存入消息队列
        messagesFromNative.push(msgs);
        // Always process async to avoid exceptions messing up stack.
        // 在下一个event loop处理消息
        nextTick(processMessages);
      }
    }
</code></pre>
<p>androidExec方法内通过nativeApiProvider.get方法，来获取一个特定的对象，然后调用exec方法，这个特定对象的exec方法就会真正执行到Native端的代码。<br>nativeApiProvider.get方法对外隐藏了Js调用native存在两种方式的细节，深入nativeApiProvider.get方法可以查看到JS调用native的两种方式的差别。nativeApiProvider.get方法定义在 ‘cordova/android/nativeapiprovider’ 这个module内</p>
<pre><code class="javascript">define(&quot;cordova/android/nativeapiprovider&quot;, function (require, exports, module) {
    /**
     * Exports the ExposedJsApi.java object if available, otherwise exports the PromptBasedNativeApi.
     */
    // _cordovaNative 由原生注册，如果没有则使用基于prompt的api调用
    // 在CordovaWebView初始化时，会根据Android版本的不同，初始化不同的JS调用Native的方法，
    // 当Android版本小于4.2(API 17)时，会采用prompt的方式处理JS的调用，当Android版本大于4.2时，会采用JavaScriptInterface的方式调用
    var nativeApi = this._cordovaNative || require(&#39;cordova/android/promptbasednativeapi&#39;);
    var currentApi = nativeApi;

    module.exports = {
      // NOTE: 这就是nativeApiProvider.get方法
      get: function () { return currentApi; },
      // 是否优先选择使用基于prompt的调用方式
      setPreferPrompt: function (value) {
        currentApi = value ? require(&#39;cordova/android/promptbasednativeapi&#39;) : nativeApi;
      },
      // Used only by tests.
      set: function (value) {
        currentApi = value;
      }
    };
  });
</code></pre>
<p>nativeApiProvider.get方法其实就是 ‘cordova/android/nativeapiprovider’ module导出的get方法，get方法返回的currentApi对象有两种可能：</p>
<ol>
<li>window._cordovaNative是Native端用@javascriptInterface注解在webview注册的原生对象。window._cordovaNative存在时意味Js调用native是通过@javascriptInterface注解注册原生对象的方式来进行。</li>
<li>window._cordovaNative不存在时，会require ‘cordova/android/promptbasednativeapi’ module，这个module内会使用基于prompt的方式与native进行通讯</li>
</ol>
<p>‘cordova/android/promptbasednativeapi’ module的代码如下:</p>
<pre><code class="javascript">define(&quot;cordova/android/promptbasednativeapi&quot;, function (require, exports, module) {
    /**
     * Implements the API of ExposedJsApi.java, but uses prompt() to communicate.
     * This is used pre-JellyBean, where addJavascriptInterface() is disabled.
     */

    module.exports = {
      exec: function (bridgeSecret, service, action, callbackId, argsJson) {
        // window.prompt 打开一个对话框 https://developer.mozilla.org/zh-CN/docs/Web/API/Window/prompt
        // native端的SystemWebChromeClient类实现了onJsPrompt方法来对js的弹窗进行拦截，然后可以执行native代码
        return prompt(argsJson, &#39;gap:&#39; + JSON.stringify([bridgeSecret, service, action, callbackId]));
      },
      setNativeToJsBridgeMode: function (bridgeSecret, value) {
        prompt(value, &#39;gap_bridge_mode:&#39; + bridgeSecret);
      },
      retrieveJsMessages: function (bridgeSecret, fromOnlineEvent) {
        return prompt(+fromOnlineEvent, &#39;gap_poll:&#39; + bridgeSecret);
      }
    };
  });
</code></pre>
<p>所以到了这一步，就已经调用到了native代码。而调用native代码的方式在这里出现了两条可能的通道：</p>
<ol>
<li>通道一 window._cordovaNative对象</li>
<li>通道二 基于prompt的方式。<br>通常在android4.2版本以上都会走通道一，android4.2以下版本因为不支持@javasciptInterface注解，所以只能走通道二。</li>
</ol>
<p>我们接下来先讨论通道一的情况。并且此时js侧的函数调用顺序大概如下：</p>
<pre><code>window.plugins.toast.show -&gt; Toast.prototype.showWithOptions -&gt; cordova.exec(实际上是androidExec方法) -&gt; nativeApiProvider.get().exec()(实际上是window._cordovaNative.exec()方法)
</code></pre><h2 id="进入native方法后如何调用到对应的插件"><a href="#进入native方法后如何调用到对应的插件" class="headerlink" title="进入native方法后如何调用到对应的插件"></a>进入native方法后如何调用到对应的插件</h2><p>js一侧调用window._cordovaNative.exec方法后，就进入了native中的SystemExposedJsApi类实例的exec方法，然后立即调用了CordovaBridge类实例的jsExec方法</p>
<pre><code class="java">// CordovaBridge类内部
public String jsExec(int bridgeSecret, String service, String action, String callbackId, String arguments) throws JSONException, IllegalAccessException {
    if (!verifySecret(&quot;exec()&quot;, bridgeSecret)) {
        return null;
    }
    // If the arguments weren&#39;t received, send a message back to JS.  It will switch bridge modes and try again.  See CB-2666.
    // We send a message meant specifically for this case.  It starts with &quot;@&quot; so no other message can be encoded into the same string.
    if (arguments == null) {
        // 如果没有传入参数则直接返回&quot;@Null arguments.&quot; js端会再次尝试用基于prompt的交流方式
        return &quot;@Null arguments.&quot;;
    }
    // 调用native插件期间暂停nativeToJS的消息传递
    jsMessageQueue.setPaused(true);
    try {
        // Tell the resourceApi what thread the JS is running on.
        CordovaResourceApi.jsThread = Thread.currentThread();
        String threadName = Thread.currentThread().getName();
        // 利用pluginManager获取指定插件名插件，然后执行
        Log.d(LOG_TAG, &quot;before pluginManager exec: &quot; + service + &quot; &quot; + action + &quot; &quot; + callbackId + &quot; &quot; + threadName);
        pluginManager.exec(service, action, callbackId, arguments);
        Log.d(LOG_TAG, &quot;after pluginManager exec: &quot; + service + &quot; &quot; + action + &quot; &quot; + callbackId + &quot; &quot; + threadName);
        String ret = null;
        if (!NativeToJsMessageQueue.DISABLE_EXEC_CHAINING) {
            // DISABLE_EXEC_CHAINING一般为false
            // 如果消息队列为空则ret为null，否则会得到一个字符串例如：&#39;len S10 callbackId len S10 callbackId*&#39;
            ret = jsMessageQueue.popAndEncode(false);
        }
        Log.d(LOG_TAG, &quot;cordova.exec return: &quot; + ret);
        return ret;
    } catch (Throwable e) {
        e.printStackTrace();
        return &quot;&quot;;
    } finally {
        jsMessageQueue.setPaused(false);
    }
}
</code></pre>
<p>CordovaBridge.jsExec方法调用了pluginManager.exec方法。在这个方法中pluginManager通过插件名找到相应的插件，然后执行插件的execute方法。</p>
<pre><code class="java">// pluginManager类内部
public void exec(final String service, final String action, final String callbackId, final String rawArgs) {
    // 按照插件名获取插件实例
    CordovaPlugin plugin = getPlugin(service);
    if (plugin == null) {
        LOG.d(TAG, &quot;exec() call to unknown plugin: &quot; + service);
        PluginResult cr = new PluginResult(PluginResult.Status.CLASS_NOT_FOUND_EXCEPTION);
        app.sendPluginResult(cr, callbackId);
        return;
    }
    // 初始化一个CallbackContext 实例
    CallbackContext callbackContext = new CallbackContext(callbackId, app);
    try {
        long pluginStartTime = System.currentTimeMillis();
        // 执行插件的execute方法，wasValidAction为false说明是一个非法action调用
        // rawArgs此时任然是一个json格式字符串，CordovaPlugin类的execute方法内对其进行了反序列化
        Log.d(TAG, &quot;before plugin execute: &quot; + service + &quot; &quot; + action);
        // 执行指定插件的execute方法，返回的boolean值意味是否是有效action
        boolean wasValidAction = plugin.execute(action, rawArgs, callbackContext);
        Log.d(TAG, &quot;after plugin execute: &quot; + service + &quot; &quot; + action);
        long duration = System.currentTimeMillis() - pluginStartTime;

        if (duration &gt; SLOW_EXEC_WARNING_THRESHOLD) {
            LOG.w(TAG, &quot;THREAD WARNING: exec() call to &quot; + service + &quot;.&quot; + action + &quot; blocked the main thread for &quot; + duration + &quot;ms. Plugin should use CordovaInterface.getThreadPool().&quot;);
        }
        if (!wasValidAction) {
            // 如果是一个非法action调用，则需要设置回调结果
            PluginResult cr = new PluginResult(PluginResult.Status.INVALID_ACTION);
            callbackContext.sendPluginResult(cr);
        }
    } catch (JSONException e) {
        PluginResult cr = new PluginResult(PluginResult.Status.JSON_EXCEPTION);
        callbackContext.sendPluginResult(cr);
    } catch (Exception e) {
        LOG.e(TAG, &quot;Uncaught exception from plugin&quot;, e);
        callbackContext.error(e.getMessage());
    }
}
</code></pre>
<p>上面的代码中从plugin.execute方法进入到插件实例的execute方法，在我们的例子中是Toast插件的execute方法。<br>Toast插件的execute方法首先判断了传入的action，然后根据不同的action进行不同的处理。这也是大多数插件的通用设计，js一侧通过传入不同的action，来调用插件的不同逻辑。</p>
<pre><code class="java">// Toast类内部
@Override
public boolean execute(String action, JSONArray args, final CallbackContext callbackContext) throws JSONException {
  if (ACTION_HIDE_EVENT.equals(action)) {
    returnTapEvent(&quot;hide&quot;, currentMessage, currentData, callbackContext);
    hide();
    callbackContext.success();
    return true;

  } else if (ACTION_SHOW_EVENT.equals(action)) {
    if (this.isPaused) {
      return true;
    }

    final JSONObject options = args.getJSONObject(0);
    final String msg = options.getString(&quot;message&quot;);
    final Spannable message = new SpannableString(msg);
    message.setSpan(
        new AlignmentSpan.Standard(Layout.Alignment.ALIGN_CENTER),
        0,
        msg.length() - 1,
        Spannable.SPAN_INCLUSIVE_INCLUSIVE);

    final String duration = options.getString(&quot;duration&quot;);
    final String position = options.getString(&quot;position&quot;);
    final int addPixelsY = options.has(&quot;addPixelsY&quot;) ? options.getInt(&quot;addPixelsY&quot;) : 0;
    final JSONObject data = options.has(&quot;data&quot;) ? options.getJSONObject(&quot;data&quot;) : null;
    final JSONObject styling = options.optJSONObject(&quot;styling&quot;);

    currentMessage = msg;
    currentData = data;
    // JavaScript运行在WebCore线程，如果需要与UI交互，则需要在UI线程运行
    cordova.getActivity().runOnUiThread(new Runnable() {
      public void run() {
        int hideAfterMs;
        if (&quot;short&quot;.equalsIgnoreCase(duration)) {
          hideAfterMs = 2000;
        } else if (&quot;long&quot;.equalsIgnoreCase(duration)) {
          hideAfterMs = 4000;
        } else {
          // assuming a number of ms
          hideAfterMs = Integer.parseInt(duration);
        }
        final android.widget.Toast toast = android.widget.Toast.makeText(
            IS_AT_LEAST_LOLLIPOP ? cordova.getActivity().getWindow().getContext() : cordova.getActivity().getApplicationContext(),
            message,
            &quot;short&quot;.equalsIgnoreCase(duration) ? android.widget.Toast.LENGTH_SHORT : android.widget.Toast.LENGTH_LONG
        );

        if (&quot;top&quot;.equals(position)) {
          toast.setGravity(GRAVITY_TOP, 0, BASE_TOP_BOTTOM_OFFSET + addPixelsY);
        } else  if (&quot;bottom&quot;.equals(position)) {
          toast.setGravity(GRAVITY_BOTTOM, 0, BASE_TOP_BOTTOM_OFFSET - addPixelsY);
        } else if (&quot;center&quot;.equals(position)) {
          toast.setGravity(GRAVITY_CENTER, 0, addPixelsY);
        } else {
          callbackContext.error(&quot;invalid position. valid options are &#39;top&#39;, &#39;center&#39; and &#39;bottom&#39;&quot;);
          return;
        }

        // if one of the custom layout options have been passed in, draw our own shape
        if (styling != null &amp;&amp; Build.VERSION.SDK_INT &gt;= 16) {

          // the defaults mimic the default toast as close as possible
          final String backgroundColor = styling.optString(&quot;backgroundColor&quot;, &quot;#333333&quot;);
          final String textColor = styling.optString(&quot;textColor&quot;, &quot;#ffffff&quot;);
          final Double textSize = styling.optDouble(&quot;textSize&quot;, -1);
          final double opacity = styling.optDouble(&quot;opacity&quot;, 0.8);
          final int cornerRadius = styling.optInt(&quot;cornerRadius&quot;, 100);
          final int horizontalPadding = styling.optInt(&quot;horizontalPadding&quot;, 50);
          final int verticalPadding = styling.optInt(&quot;verticalPadding&quot;, 30);

          GradientDrawable shape = new GradientDrawable();
          shape.setCornerRadius(cornerRadius);
          shape.setAlpha((int)(opacity * 255)); // 0-255, where 0 is an invisible background
          shape.setColor(Color.parseColor(backgroundColor));
          toast.getView().setBackground(shape);

          final TextView toastTextView;
          toastTextView = (TextView) toast.getView().findViewById(android.R.id.message);
          toastTextView.setTextColor(Color.parseColor(textColor));
          if (textSize &gt; -1) {
            toastTextView.setTextSize(textSize.floatValue());
          }

          toast.getView().setPadding(horizontalPadding, verticalPadding, horizontalPadding, verticalPadding);

          // this gives the toast a very subtle shadow on newer devices
          if (Build.VERSION.SDK_INT &gt;= 21) {
            toast.getView().setElevation(6);
          }
        }

        // On Android &gt;= 5 you can no longer rely on the &#39;toast.getView().setOnTouchListener&#39;,
        // so created something funky that compares the Toast position to the tap coordinates.
        if (IS_AT_LEAST_LOLLIPOP) {
          getViewGroup().setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View view, MotionEvent motionEvent) {
              if (motionEvent.getAction() != MotionEvent.ACTION_DOWN) {
                return false;
              }
              if (mostRecentToast == null || !mostRecentToast.getView().isShown()) {
                getViewGroup().setOnTouchListener(null);
                return false;
              }

              float w = mostRecentToast.getView().getWidth();
              float startX = (view.getWidth() / 2) - (w / 2);
              float endX = (view.getWidth() / 2) + (w / 2);

              float startY;
              float endY;

              float g = mostRecentToast.getGravity();
              float y = mostRecentToast.getYOffset();
              float h = mostRecentToast.getView().getHeight();

              if (g == GRAVITY_BOTTOM) {
                startY = view.getHeight() - y - h;
                endY = view.getHeight() - y;
              } else if (g == GRAVITY_CENTER) {
                startY = (view.getHeight() / 2) + y - (h / 2);
                endY = (view.getHeight() / 2) + y + (h / 2);
              } else {
                // top
                startY = y;
                endY = y + h;
              }

              float tapX = motionEvent.getX();
              float tapY = motionEvent.getY();

              final boolean tapped = tapX &gt;= startX &amp;&amp; tapX &lt;= endX &amp;&amp;
                  tapY &gt;= startY &amp;&amp; tapY &lt;= endY;

              return tapped &amp;&amp; returnTapEvent(&quot;touch&quot;, msg, data, callbackContext);
            }
          });
        } else {
          toast.getView().setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View view, MotionEvent motionEvent) {
              return motionEvent.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; returnTapEvent(&quot;touch&quot;, msg, data, callbackContext);
            }
          });
        }
        // trigger show every 2500 ms for as long as the requested duration
        _timer = new CountDownTimer(hideAfterMs, 2500) {
          public void onTick(long millisUntilFinished) {
            // see https://github.com/EddyVerbruggen/Toast-PhoneGap-Plugin/issues/116
            // and https://github.com/EddyVerbruggen/Toast-PhoneGap-Plugin/issues/120
//              if (!IS_AT_LEAST_PIE) {
//                toast.show();
//              }
          }
          public void onFinish() {
            returnTapEvent(&quot;hide&quot;, msg, data, callbackContext);
            toast.cancel();
          }
        }.start();

        mostRecentToast = toast;
        toast.show();

        PluginResult pr = new PluginResult(PluginResult.Status.OK);
        // 暂时keep住callback
        pr.setKeepCallback(true);
        callbackContext.sendPluginResult(pr);
      }
    });

    return true;
  } else {
    callbackContext.error(&quot;toast.&quot; + action + &quot; is not a supported function. Did you mean &#39;&quot; + ACTION_SHOW_EVENT + &quot;&#39;?&quot;);
    return false;
  }
}
</code></pre>
<p>我们的示例中调用show这个action。show这个action主要做的事情是在UI线程设置一段运行的代码，这段代码主要是在UI线程显示toast，然后调用callbackContext.sendPluginResult方法，发送插件运行结果，该方法调用会引发js侧的方法回调。设置好了UI线程调用的代码后，Toast类的execute方法返回了一个true，结束了这个方法。后续会依次返回pluginManager.exec、CordovaBridge.jsExec、SystemExposedJsApi.exec方法。当SystemExposedJsApi.exec方法返回的时候，对应了js侧的nativeApiProvider.get().exec()方法的返回。</p>
<p>此时的函数调用栈情况大概如下：</p>
<pre><code class="javascript">// 以下方法运行在WebCore线程
window.plugins.toast.show()
  Toast.prototype.showWithOptions()
    cordova.exec()
      nativeApiProvider.get().exec() // 从这里进入原生代码
        SystemExposedJsApi.exec()
          CordovaBridge.jsExec()
            PluginManager.exec()
              CordovaPlugin.execute()
                Toast.execute() // 在这里执行业务逻辑
              CordovaPlugin.execute()
            PluginManager.exec()
          CordovaBridge.jsExec()
        SystemExposedJsApi.exec() // 从原生代码返回
      nativeApiProvider.get().exec()
    cordova.exec()
  Toast.prototype.showWithOptions()
window.plugins.toast.show()
</code></pre>
<h2 id="native中的线程与js中的异步"><a href="#native中的线程与js中的异步" class="headerlink" title="native中的线程与js中的异步"></a>native中的线程与js中的异步</h2><p>在继续讲述Native插件如何对js进行回调前，先介绍一下native中的线程与js中的异步。<br>javaScript都是运行在WebCore线程上的，所以上述从js到native再到插件的execute方法的调用都发生在WebCore线程，当插件内需要操作UI时，则需要切换到UI线程,<a href="https://cordova.apache.org/docs/en/2.6.0/guide/plugin-development/android/#threading" target="_blank" rel="noopener">详细可点击此处查看文档</a>。在Toast插件的show action中就是如此，因为要在UI上显示toast，所以切换到UI线程来执行显示toast的代码，并且在UI线程上发送了插件运行结果，进而对js一侧进行了回调，所以在js一侧插件回调函数的执行是异步的。<br>对于部分插件来说，并不需要在execute方法内切换到UI线程，可能在WebCore线程上执行完业务逻辑就马上调用callbackContext.sendPluginResult方法发送插件运行结果了，这种情况下js侧的插件回调函数是否就不是异步的呢？答案是插件回调函数依然是异步，继续深入callbackContext.sendPluginResult方法的调用栈，就会发现最终在BridgeMode类的onNativeToJsMessageAvailable方法中，js的回调最终还是被切换到UI线程中进行的（后续Native对js的回调会详细解释），所以无论插件的execute方法是否进行了线程切换，最后native对js的调用都是从WebCore线程切换到UI线程的，所以造成js侧的插件回调函数总是异步运行的。</p>
<h2 id="native端对js进行的回调"><a href="#native端对js进行的回调" class="headerlink" title="native端对js进行的回调"></a>native端对js进行的回调</h2><p>这里任然以Toast插件的回调为例子进行说明</p>
<p>Toast插件的show action处理中，先切换到了UI线程，进行toast的显示（js运行在WebCore线程，如果要操作UI必须切换到UI线程）。toast显示后调用callbackContext.sendPluginResult来发送插件运行结果。从这里开始了对js的回调过程。</p>
<pre><code class="java">// 在Toast插件内
@Override
  public boolean execute(String action, JSONArray args, final CallbackContext callbackContext) throws JSONException {
    if (ACTION_HIDE_EVENT.equals(action)) {
      ...
    } else if (ACTION_SHOW_EVENT.equals(action)) {
      ...
      // JavaScript运行在WebCore线程，如果需要与UI交互，则需要在UI线程运行
      cordova.getActivity().runOnUiThread(new Runnable() {
        public void run() {

          ...

          toast.show();
          // 创建一个插件运行结果
          PluginResult pr = new PluginResult(PluginResult.Status.OK);
          // 暂时keep住callback
          pr.setKeepCallback(true);
          // 调用callbackContext.sendPluginResult发送插件运行结果
          callbackContext.sendPluginResult(pr);
        }
      });

      return true;
    } else {
      callbackContext.error(&quot;toast.&quot; + action + &quot; is not a supported function. Did you mean &#39;&quot; + ACTION_SHOW_EVENT + &quot;&#39;?&quot;);
      return false;
    }
  }
</code></pre>
<p>PluginResult实例代表插件运行结果，callbackContext实例则代表着native对js的回调。sendPluginResult方法内部调用了webView.sendPluginResult方法，将PluginResult传递给webview。webView.sendPluginResult又调用nativeToJsMessageQueue.addPluginResult方法把PluginResult和callbackId传递给了sendPluginResult又调用nativeToJsMessageQueue。</p>
<pre><code class="java">// CallBackContent类内部
// 插件运行完毕，设置结果，同时将结果实例传入webview
public void sendPluginResult(PluginResult pluginResult) {
    synchronized (this) {
        if (finished) {
            LOG.w(LOG_TAG, &quot;Attempted to send a second callback for ID: &quot; + callbackId + &quot;\nResult was: &quot; + pluginResult.getMessage());
            return;
        } else {
            // 如果keepCallback为true，则finished为false，否则为true
            finished = !pluginResult.getKeepCallback();
        }
    }
    webView.sendPluginResult(pluginResult, callbackId);
}
</code></pre>
<pre><code class="java">// CordovaWebViewImpl类内部
// 发送一个插件结果实例，通常是由callbackContext类调用
@Override
public void sendPluginResult(PluginResult cr, String callbackId) {
    nativeToJsMessageQueue.addPluginResult(cr, callbackId);
}
</code></pre>
<p>nativeToJsMessageQueue实例存储着native发送到js的消息队列。addPluginResult方法内会把PluginResult实例封装成JsMessage实例，然后调用enqueueMessage方法将JsMessage实例推入队列，然后马上对消息队列进行处理。队列内的消息是由activeBridgeMode实例的onNativeToJsMessageAvailable方法进行处理的。</p>
<pre><code class="java">// NativeToJsMessageQueue类内部
public void addPluginResult(PluginResult result, String callbackId) {
    if (callbackId == null) {
        LOG.e(LOG_TAG, &quot;Got plugin result with no callbackId&quot;, new Throwable());
        return;
    }
    // Don&#39;t send anything if there is no result and there is no need to
    // clear the callbacks.
    boolean noResult = result.getStatus() == PluginResult.Status.NO_RESULT.ordinal();
    boolean keepCallback = result.getKeepCallback();
    // 如果结果状态是noResult，同时keepCallback，则没有必要回调js
    if (noResult &amp;&amp; keepCallback) {
        return;
    }
    // 将插件结果封装成jsMessage对象
    JsMessage message = new JsMessage(result, callbackId);
    // 通常为false
    if (FORCE_ENCODE_USING_EVAL) {
        StringBuilder sb = new StringBuilder(message.calculateEncodedLength() + 50);
        message.encodeAsJsMessage(sb);
        message = new JsMessage(sb.toString());
    }
    // 将消息入队列
    enqueueMessage(message);
}
// 添加消息进入队列并且使用mode实例进行处理
private void enqueueMessage(JsMessage message) {
    synchronized (this) {
        if (activeBridgeMode == null) {
            LOG.d(LOG_TAG, &quot;Dropping Native-&gt;JS message due to disabled bridge&quot;);
            return;
        }
        queue.add(message);
        if (!paused) {
            // 如果当前没有暂停,则调用当前激活的mode实例来处理
            activeBridgeMode.onNativeToJsMessageAvailable(this);
        }
    }
}
</code></pre>
<p>activeBridgeMode实例代表着native调用js的具体实现模式，通常会在cordova.js初始化的时候，通过js调用原生方法的方式设置为EvalBridgeMode类实例。所以这里查看EvalBridgeMode类的onNativeToJsMessageAvailable方法</p>
<pre><code class="java">// EvalBridgeMode类内部
@Override
public void onNativeToJsMessageAvailable(final NativeToJsMessageQueue queue) {
    // plugin的execute方法运行在WebCore线程，在WebCore线程中return
    // 而执行callback的webView方法必须在UI线程运行的，所以在js中callback是异步的
    String threadName = Thread.currentThread().getName();
    Log.d(LOG_TAG, &quot;in onNativeToJsMessageAvailable: &quot; + threadName);
    cordova.getActivity().runOnUiThread(new Runnable() {
        public void run() {
            String threadName = Thread.currentThread().getName();
            Log.d(LOG_TAG, &quot;beforeCallback: &quot; + threadName);
            // 将jsMessage实例转换成js代码字符串
            String js = queue.popAndEncodeAsJs();
            if (js != null) {
                engine.evaluateJavascript(js, null);
            }
        }
    });
}
</code></pre>
<p>值得注意的是onNativeToJsMessageAvailable方法内，强制切换到UI线程，在UI线程内将队列内的jsMessage实例转换成js代码字符串，然后将js代码字符串传入engine。engine.evaluateJavascript调用了android原生的webView.evaluateJavascript来执行js代码字符串，最后在js一侧触发了插件回调函数。</p>
<p>onNativeToJsMessageAvailable方法内，强制切换到UI线程的原因是，webview的evaluateJavascript方法只能在UI线程进行调用。这也造成了js一侧插件调用和回调函数总是异步的特性。</p>
<p>最后附上native回调js的一个函数调用过程</p>
<pre><code class="java">// 以下方法调用栈可能在任一线程
callbackContext.sendPluginResult(pluginResult) // 发送插件运行实例
  webView.sendPluginResult(pluginResult, callbackId); 
    nativeToJsMessageQueue.addPluginResult(cr, callbackId); // 在这里把PluginResult封装成JsMessage
      nativeToJsMessageQueue.enqueueMessage(jsmessage)
        activeBridgeMode.onNativeToJsMessageAvailable() // 在这个方法内切换到UI线程，运行执行js的逻辑
      nativeToJsMessageQueue.enqueueMessage(jsmessage)
    nativeToJsMessageQueue.addPluginResult(cr, callbackId);
  webView.sendPluginResult(pluginResult, callbackId);
callbackContext.sendPluginResult(pluginResult)

// 以下方法调用栈运行在UI线程，由activeBridgeMode.onNativeToJsMessageAvailable开启
queue.popAndEncodeAsJs(); // 在这里将jsMessage实例转换成js代码字符串
engine.evaluateJavascript(js, null);
  webView.evaluateJavascript(js, callback); // 进入js侧的回调函数
engine.evaluateJavascript(js, null);

// 调用webView.evaluateJavascript(js, callback);之后，js侧的函数调用栈
cordova.callbackFromNative(callbackId, isSuccess, status, args, keepCallback)
  callback.success or callback.fail // 根据isSuccess决定调用成功回调函数，或者失败回调函数。
cordova.callbackFromNative(callbackId, isSuccess, status, args, keepCallback)
</code></pre>
<p>以上就是js调用Native，以及Native回调Js的大概过程</p>

        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2019/06/23/Cordova源码剖析二（cordova-js启动流程）/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/random/material-13.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/touxiang.jpg" alt="aasailan's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        joeaasailan@gmail.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="mailto:joeaasailan@gmail.com" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2019/06/">六月 2019<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/02/">二月 2019<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/07/">七月 2018<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/06/">六月 2018<span class="sidebar_archives-count">3</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">chrome_reader_mode</i>
                
                分类
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
                <li>
                <a class="sidebar_archives-link" href="/categories/cordova系列/">cordova系列<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/categories/css系列/">css系列<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/docker/">docker<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/hexo/">hexo<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/js/">js<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/categories/翻译系列/">翻译系列<span class="sidebar_archives-count">1</span></a>
            </ul>
        </li>
        
    

    <!-- Pages  -->
    
        <li>
            <a href="/tags" title="标签云">
                
                标签云
            </a>
        </li>
        
    
        <li>
            <a href="/timeline" title="时间轴">
                
                时间轴
            </a>
        </li>
        
    

    <!-- Article Number  -->
    
        <li>
            <a href="/archives">
                文章总数
                <span class="sidebar-badge">12</span>
            </a>
        </li>
        
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    

    <!-- Google + -->
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/aasailan" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-github">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
    
    <!-- V2EX -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;2018&nbsp;-<script type="text/javascript">var fd = new Date();document.write("&nbsp;" + fd.getFullYear() + "&nbsp;");</script>aasailan的blog
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?wgjW/HuQG9JDgvPDPoRAng==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?d+XW6aNuIPgOn1iA7NnB4g==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>



    
        <script>lsloader.load("sm_js","/js/smoothscroll.js?tNQK2Tw2SUL8a1Scn/Mgew==", true)</script>
    











<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->


    
        <script>lsloader.load("hanabi","/js/hanabi-browser-bundle.js?5+2z7ZZmFuZK5IcimlZbxw==", true)</script>
    


<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
    
        
        
        HanabiBrowser.start('pre code',true);
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.2 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
            <script type="text/javascript" color="112,255,59" opacity='1' zIndex="0" count="99" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
        </body>
    
</html>
